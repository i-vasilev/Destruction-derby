package ru.rsreu.vasilev.dd.model;import javafx.geometry.Bounds;import javafx.scene.Node;import javafx.scene.shape.Polygon;import javafx.scene.shape.Shape;import ru.rsreu.vasilev.dd.view.*;import java.util.HashSet;import java.util.Set;public class Car extends Thread {    private static final double ANGLE_CHANGE = 0.1;    private static final int TIME_SLEEP = 20;    private final Point position;    private ObjectListener objectListener;    private double speed = 0;    private double angle = 0;    private static final double ACCELERATION = 0.2;    private boolean isNeedUpdate = true;    private static final double MAX_SPEED = 6;    private final Model modelGame;    private Set<Direction> directions;    private int lives = 10;    public Car(Model modelGame, int x, int y, Listener listener) {        this.position = new Point(x, y);        this.modelGame = modelGame;        setDaemon(true);        directions = new HashSet<>();        listener.handle(this, EventType.CREATE_CAR);    }    @Override    public void run() {        while (!isInterrupted()) {            if (isNeedUpdate) {                isNeedUpdate = false;                updateSpeeds();                moveCar();                checkCollides();                checkWin();            } else {                speedDown();            }            try {                sleep(TIME_SLEEP);            } catch (InterruptedException e) {                break;            }        }    }    private void checkCollides() {        final Polygon polygon = getPolygon();        final Bounds boundsInParent = polygon.getBoundsInParent();        double newMinX = boundsInParent.getMinX() + getSpeedX();        double newMinY = boundsInParent.getMinY() + getSpeedY();        double newMaxX = boundsInParent.getMaxX() + getSpeedX();        double newMaxY = boundsInParent.getMaxY() + getSpeedY();        if (isCollidedCars() && !isNotCollidedWall(newMinX, newMinY) && !isNotCollidedWall(newMaxX, newMaxY)) {            speed = -2 * speed;            moveCar();            speed = 0;        }    }    private double getSpeedY() {        return Math.cos(angle) * speed;    }    private double getSpeedX() {        return Math.sin(angle) * speed;    }    private void checkWin() {        if ((int) (position.getX() / View.WIDTH_SQUARE) == (int) (modelGame.getFinalPoint().getX()) &&                modelGame.getHeight() - 1 - (int) (position.getY() / View.WIDTH_SQUARE) ==                        (int) (modelGame.getFinalPoint().getY())) {            modelGame.stopAllCars(this);        }    }    private void moveCar() {        double newX = position.getX() + getSpeedX();        double newY = position.getY() + getSpeedY();//        final Polygon polygon = getPolygon();//        final Bounds boundsInParent = polygon.getBoundsInParent();//        double newMinX = boundsInParent.getMinX() + getSpeedX();//        double newMinY = boundsInParent.getMinY() + getSpeedY();//        double newMaxX = boundsInParent.getMaxX() + getSpeedX();//        double newMaxY = boundsInParent.getMaxY() + getSpeedY();//        if (isNotCollidedWall(newMinX, newMinY) && isNotCollidedWall(newMaxX, newMaxY)) {            position.setY(newY);            position.setX(newX);//        }        objectListener.handle(this, ObjectEventType.UPDATE);    }    private boolean isNotCollidedWall(double newX, double newY) {        return modelGame.getHeight() > ((int) newY / View.WIDTH_SQUARE) && newY > 0 &&                modelGame.getWidth() > (int) newX / View.WIDTH_SQUARE && newX >= 0 &&                modelGame.getMap()[modelGame.getHeight() - (int) newY / View.WIDTH_SQUARE - 1][                        (int) newX / View.WIDTH_SQUARE];    }    private boolean isCollidedCars() {        synchronized (Model.BLOCK) {            boolean isCollided = false;            for (Car car :                    modelGame.getCars()) {                if (!car.equals(this)) {                    if (isCollided(car)) {                        isCollided = true;                        if (lives > 1) {                            lives--;                        } else {                            this.interrupt();                        }                    }                }            }            return isCollided;        }    }    private boolean isCollided(Car car) {        final Polygon bounds = getPolygon();        return !Shape.intersect(bounds, car.getPolygon()).getBoundsInLocal().isEmpty();    }    private void updateSpeeds() {        if (directions.contains(Direction.UP)) {            speedUp(MovingDirection.FORWARD);        } else if (directions.contains(Direction.DOWN)) {            speedUp(MovingDirection.BACKWARD);        }        if (directions.contains(Direction.RIGHT)) {            rotate(Direction.RIGHT);        } else if (directions.contains(Direction.LEFT)) {            rotate(Direction.LEFT);        }    }    private void speedUp(MovingDirection movingDirection) {        isNeedUpdate = true;        if (MAX_SPEED > speed) {            speed += ACCELERATION * (movingDirection == MovingDirection.BACKWARD ? -1 : 1);        }    }    private void rotate(Direction direction) {        if (direction == Direction.LEFT) {            angle -= ANGLE_CHANGE;        } else {            angle += ANGLE_CHANGE;        }    }    private void speedDown() {        isNeedUpdate = true;        if (speed > 0) {            speed -= ACCELERATION;        } else if (speed < 0) {            speed += ACCELERATION;        }    }    public Point getPosition() {        return position;    }    public void setObjectListener(ObjectListener objectListener) {        this.objectListener = objectListener;    }    public double getAngle() {        return Math.toDegrees(angle);    }    public Set<Direction> getDirections() {        return directions;    }    public Polygon getPolygon() {        return (Polygon) objectListener;    }}