package ru.rsreu.vasilev.dd.model;import javafx.geometry.Bounds;import javafx.scene.shape.Polygon;import javafx.scene.shape.Shape;import ru.rsreu.vasilev.dd.view.*;import java.util.HashSet;import java.util.Set;public class Car extends Thread {    private static final double ANGLE_CHANGE = 0.1;    private static final int TIME_SLEEP = 20;    private final Point position;    private ObjectListener objectListener;    private double speed = 0;    private double angle = 0;    private static final double ACCELERATION = 0.2;    private boolean isNeedUpdate = true;    private static final double MAX_SPEED = 6;    private final Model modelGame;    private final Set<Direction> directions;    private int lives = 10;    private boolean isStopped = false;    private final String name;    public Car(Model modelGame, int x, int y, Listener listener, String name) {        this.position = new Point(x, y);        this.modelGame = modelGame;        setDaemon(true);        directions = new HashSet<>();        listener.handle(this, EventType.CREATE_CAR);        this.name = name;    }    @Override    public void run() {        while (!isInterrupted()) {            if (isNeedUpdate) {                isNeedUpdate = false;                updateSpeeds();                moveCar();                checkCollides();                checkWin();            } else {                speedDown();            }            try {                sleep(TIME_SLEEP);            } catch (InterruptedException e) {                break;            }        }    }    private double getSpeedY() {        return Math.cos(angle) * speed;    }    private double getSpeedX() {        return Math.sin(angle) * speed;    }    private void checkWin() {        if ((int) (position.getX() / View.WIDTH_SQUARE) == (int) (modelGame.getFinalPoint().getX()) &&                modelGame.getHeight() - 1 - (int) (position.getY() / View.WIDTH_SQUARE) ==                        (int) (modelGame.getFinalPoint().getY())) {            modelGame.stopAllCars(this);        }    }    private void moveCar() {        double newX = position.getX() + getSpeedX();        double newY = position.getY() + getSpeedY();        position.setY(newY);        position.setX(newX);        objectListener.handle(this, ObjectEventType.UPDATE);    }    private void checkCollides() {        if (isCollidedCars() || isNotCollidesWalls()) {            speed = -2 * speed;            moveCar();            speed = 0;        }    }    private boolean isNotCollidesWalls() {        final int topOffset = View.HEIGHT_TOP_PANEL / View.WIDTH_SQUARE;        final Polygon polygon = getPolygon();        final Bounds boundsInParent = polygon.getBoundsInParent();        double newMinX = (boundsInParent.getMinX() + getSpeedX()) / View.WIDTH_SQUARE;        double newMinY = (boundsInParent.getMinY() + getSpeedY()) / View.WIDTH_SQUARE - topOffset;        double newMaxX = (boundsInParent.getMaxX() + getSpeedX()) / View.WIDTH_SQUARE;        double newMaxY = (boundsInParent.getMaxY() + getSpeedY()) / View.WIDTH_SQUARE - topOffset;        return isCollidedWall(newMinX, newMinY) || isCollidedWall(newMaxX, newMaxY);    }    private boolean isCollidedWall(double newX, double newY) {        return modelGame.getHeight() <= ((int) newY) || (newY <= 0) ||                modelGame.getWidth() <= (int) newX || (newX < 0) ||                !modelGame.getMap()[(int) newY][(int) newX];    }    private boolean isCollidedCars() {        synchronized (Model.BLOCK) {            boolean isCollided = false;            for (Car car : modelGame.getCars()) {                if (!car.equals(this)) {                    if (isCollidedCar(car)) {                        isCollided = true;                        if (lives > 1) {                            lives--;                        } else {                            this.interrupt();                        }                    }                }            }            return isCollided;        }    }    private boolean isCollidedCar(Car car) {        final Polygon bounds = getPolygon();        return !Shape.intersect(bounds, car.getPolygon()).getBoundsInLocal().isEmpty();    }    private void updateSpeeds() {        if (!isStopped) {            if (directions.contains(Direction.UP) && !isNotCollidesWalls()) {                speedUp(MovingDirection.FORWARD);            } else if (directions.contains(Direction.DOWN) && !isNotCollidesWalls()) {                speedUp(MovingDirection.BACKWARD);            }            if (directions.contains(Direction.RIGHT)) {                rotate(Direction.RIGHT);            } else if (directions.contains(Direction.LEFT)) {                rotate(Direction.LEFT);            }        }    }    private void speedUp(MovingDirection movingDirection) {        isNeedUpdate = true;        if (MAX_SPEED > speed) {            speed += ACCELERATION * (movingDirection == MovingDirection.BACKWARD ? -1 : 1);        }    }    private void rotate(Direction direction) {        if (direction == Direction.LEFT) {            angle -= ANGLE_CHANGE;        } else {            angle += ANGLE_CHANGE;        }    }    private void speedDown() {        isNeedUpdate = true;        if (speed > 0) {            speed -= ACCELERATION;        } else if (speed < 0) {            speed += ACCELERATION;        }    }    public Point getPosition() {        return position;    }    public void setObjectListener(ObjectListener objectListener) {        this.objectListener = objectListener;    }    public double getAngle() {        return Math.toDegrees(angle);    }    public Set<Direction> getDirections() {        return directions;    }    public Polygon getPolygon() {        return (Polygon) objectListener;    }    public void setStopped(boolean stopped) {        isStopped = stopped;    }    @Override    public String toString() {        return name;    }}