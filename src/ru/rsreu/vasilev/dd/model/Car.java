package ru.rsreu.vasilev.dd.model;import java.util.HashSet;import java.util.Random;import java.util.Set;import javafx.scene.input.KeyCode;import ru.rsreu.vasilev.dd.view.EventType;import ru.rsreu.vasilev.dd.view.Listener;import ru.rsreu.vasilev.dd.view.ObjectEventType;import ru.rsreu.vasilev.dd.view.ObjectListener;import ru.rsreu.vasilev.dd.view.View;public class Car extends Thread {    private static final double ANGLE_CHANGE = 0.1;    private static final int TIME_SLEEP = 20;    private final Point position;    private final Listener listenerGame;    private ObjectListener objectListener;    private double speed = 0;    private double angle = 0;    private static final double ACCELERATION = 0.2;    private boolean isPlayUser = false;    private boolean isNeedUpdate = true;    private static final double MAX_SPEED = 6;    private final Set<KeyCode> pressedKeys = new HashSet<>();    private final Model modelGame;    private Random rnd = new Random();    public Car(Model modelGame, int x, int y, Listener listener, boolean isPlayUser) {        this(modelGame, x, y, listener);        this.isPlayUser = isPlayUser;    }    public Car(Model modelGame, int x, int y, Listener listener) {        this.position = new Point(x, y);        this.modelGame = modelGame;        setDaemon(true);        listenerGame = listener;        listenerGame.handle(this, EventType.CREATE_CAR);    }    @Override    public void run() {        while (true) {            if (isNeedUpdate) {                if (!isPlayUser) {                    checkMapAndSetKeys();                    speedUp(MovingDirection.FORWARD);                } else {                    isNeedUpdate = false;                }                updateSpeeds();                double speedY = Math.cos(angle) * speed;                double speedX = Math.sin(angle) * speed;                moveCar(speedY, speedX);                objectListener.handle(this, ObjectEventType.UPDATE);            } else {                speedDown();            }            try {                sleep(TIME_SLEEP);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private synchronized void moveCar(double speedY, double speedX) {        double newY = position.getY() + speedY;        double newX = position.getX() + speedX;        if (modelGame.getHeight() > ((int) newY / View.WIDTH_SQUARE - 1) &&                modelGame.getHeight() > ((int) newY / View.WIDTH_SQUARE) && newY > 0 &&                modelGame.getWidth() > (int) newX / View.WIDTH_SQUARE && newX >= 0 &&                modelGame.getMap()[modelGame.getHeight() - (int) newY / View.WIDTH_SQUARE - 1][                        (int) newX / View.WIDTH_SQUARE]) {            position.setY(newY);            position.setX(newX);        }    }    public void updateSpeeds() {        if (pressedKeys.contains(KeyCode.UP)) {            speedUp(MovingDirection.FORWARD);        } else if (pressedKeys.contains(KeyCode.DOWN)) {            speedUp(MovingDirection.BACKWARD);        }        if (pressedKeys.contains(KeyCode.RIGHT)) {            rotate(Direction.RIGHT);        } else if (pressedKeys.contains(KeyCode.LEFT)) {            rotate(Direction.LEFT);        }    }    public void speedUp(MovingDirection movingDirection) {        isNeedUpdate = true;        if (MAX_SPEED > speed) {            speed += ACCELERATION * (movingDirection == MovingDirection.BACKWARD ? -1 : 1);        }    }    public void rotate(Direction direction) {        if (direction == Direction.LEFT) {            angle -= ANGLE_CHANGE;        } else {            angle += ANGLE_CHANGE;        }    }    public void speedDown() {        isNeedUpdate = true;        if (speed > 0) {            speed -= ACCELERATION;        } else if (speed < 0) {            speed += ACCELERATION;        }    }    private boolean getDeviation(Direction direction) {        double deviation = Math.abs((angle) / (Math.PI / 2));        deviation = Math.abs(deviation - (int) deviation);        if (direction != getDirection()) {            return false;        }        return deviation > 0.95 || deviation < 0.06;    }    private Direction getDirection() {        final Direction direction;        final boolean isOdd = (int) (angle / Math.PI / 2) == 0;        final boolean isPositive = angle > 0;        final double absAngle = Math.abs(angle);        boolean isHorizontal = absAngle % Math.PI > Math.PI / 4 && absAngle % Math.PI <= 3 * Math.PI / 4;        if (isOdd ^ isPositive) {            if (absAngle % Math.PI <= Math.PI / 4) {                direction = !isPositive ? Direction.UP : Direction.DOWN;            } else if (isHorizontal) {                direction = Direction.LEFT;            } else {                direction = !isOdd ? Direction.UP : Direction.DOWN;            }        } else {            if (absAngle % Math.PI <= Math.PI / 4) {                direction = isOdd ? Direction.UP : Direction.DOWN;            } else if (isHorizontal) {                direction = Direction.RIGHT;            } else {                direction = !isOdd ? Direction.UP : Direction.DOWN;            }        }        return direction;    }    private boolean isHasClearWay(Direction direction) {        int y = (int) (modelGame.getHeight() - getPosition().getY() / 100);        int x = (int) (getPosition().getX() / 100);        if (direction.equals(Direction.RIGHT)) {            x++;        } else if (direction.equals(Direction.LEFT)) {            x--;        } else if (direction.equals(Direction.DOWN)) {            y++;        } else {            y--;        }        if (x >= 0 && x < modelGame.getWidth() && y >= 0 && y < modelGame.getHeight()) {            return modelGame.getMap()[y][x];        }        return false;    }    public void checkMapAndSetKeys() {        if (rnd.nextDouble() > 0.35) {            final Direction direction = getDirection();            final boolean rightWay;            final boolean leftWay;            final boolean upWay = isHasClearWay(direction);            Direction direction1 = direction;            if (direction.equals(Direction.RIGHT)) {                rightWay = isHasClearWay(Direction.DOWN);                if (!upWay && rightWay) {                    direction1 = Direction.DOWN;                }                leftWay = isHasClearWay(Direction.UP);                if (!upWay && leftWay) {                    direction1 = Direction.UP;                }            } else if (direction.equals(Direction.UP)) {                rightWay = isHasClearWay(Direction.RIGHT);                if (!upWay && rightWay) {                    direction1 = Direction.RIGHT;                }                leftWay = isHasClearWay(Direction.LEFT);                if (!upWay && leftWay) {                    direction1 = Direction.LEFT;                }            } else if (direction.equals(Direction.LEFT)) {                rightWay = isHasClearWay(Direction.UP);                if (!upWay && rightWay) {                    direction1 = Direction.UP;                }                leftWay = isHasClearWay(Direction.DOWN);                if (!upWay && leftWay) {                    direction1 = Direction.DOWN;                }            } else {                rightWay = isHasClearWay(Direction.LEFT);                if (!upWay && rightWay) {                    direction1 = Direction.LEFT;                }                leftWay = isHasClearWay(Direction.RIGHT);                if (!upWay && leftWay) {                    direction1 = Direction.RIGHT;                }            }            if (!upWay) {                if (rightWay) {                    removeKey(KeyCode.LEFT);                    addKey(KeyCode.RIGHT);                } else if (leftWay) {                    removeKey(KeyCode.RIGHT);                    addKey(KeyCode.LEFT);                }            } else {                if (getDeviation(direction1)) {                    removeKey(KeyCode.RIGHT);                    removeKey(KeyCode.LEFT);                }            }        }    }    public Point getPosition() {        return position;    }    public void setObjectListener(ObjectListener objectListener) {        this.objectListener = objectListener;    }    public double getAngle() {        return (angle * 180) / Math.PI;    }    public void addKey(KeyCode keyCode) {        pressedKeys.add(keyCode);    }    public void removeKey(KeyCode keyCode) {        pressedKeys.remove(keyCode);    }}