package ru.rsreu.vasilev.dd.model;import javafx.scene.input.KeyCode;import ru.rsreu.vasilev.dd.view.*;import java.util.Map;public class Car extends Thread {    private static final double ANGLE_CHANGE = 0.1;    private static final int TIME_SLEEP = 20;    private final Point position;    private final Listener listenerGame;    private ObjectListener objectListener;    private double speed = 0;    private double angle = 0;    private static final double ACCELERATION = 0.2;    private boolean isNeedUpdate = true;    private static final double MAX_SPEED = 6;    private final Model modelGame;    private Map<Direction, KeyCode> keys;    public Car(Model modelGame, int x, int y, Listener listener, Map<Direction, KeyCode> keys) {        this.position = new Point(x, y);        this.modelGame = modelGame;        setDaemon(true);        listenerGame = listener;        listenerGame.handle(this, EventType.CREATE_CAR);        this.keys = keys;    }    @Override    public void run() {        while (!isInterrupted()) {            if (isNeedUpdate) {                isNeedUpdate = false;                updateSpeeds();                double speedY = Math.cos(angle) * speed;                double speedX = Math.sin(angle) * speed;                moveCar(speedY, speedX);                objectListener.handle(this, ObjectEventType.UPDATE);                checkWin();            } else {                speedDown();            }            try {                sleep(TIME_SLEEP);            } catch (InterruptedException e) {                break;            }        }    }    private void checkWin() {        if ((int) (position.getX() / View.WIDTH_SQUARE) == (int) (modelGame.getFinalPoint().getX()) &&                modelGame.getHeight() - 1 - (int) (position.getY() / View.WIDTH_SQUARE) == (int) (modelGame.getFinalPoint().getY())) {            modelGame.stopAllCars();        }    }    private void moveCar(double speedY, double speedX) {        double newY = position.getY() + speedY;        double newX = position.getX() + speedX;        if (modelGame.getHeight() > ((int) newY / View.WIDTH_SQUARE - 1) &&                modelGame.getHeight() > ((int) newY / View.WIDTH_SQUARE) && newY > 0 &&                modelGame.getWidth() > (int) newX / View.WIDTH_SQUARE && newX >= 0 &&                modelGame.getMap()[modelGame.getHeight() - (int) newY / View.WIDTH_SQUARE - 1][                        (int) newX / View.WIDTH_SQUARE]) {            position.setY(newY);            position.setX(newX);        }    }    public void updateSpeeds() {        if (modelGame.getPressedKeys().contains(keys.get(Direction.UP))) {            speedUp(MovingDirection.FORWARD);        } else if (modelGame.getPressedKeys().contains(keys.get(Direction.DOWN))) {            speedUp(MovingDirection.BACKWARD);        }        if (modelGame.getPressedKeys().contains(keys.get(Direction.RIGHT))) {            rotate(Direction.RIGHT);        } else if (modelGame.getPressedKeys().contains(keys.get(Direction.LEFT))) {            rotate(Direction.LEFT);        }    }    public void speedUp(MovingDirection movingDirection) {        isNeedUpdate = true;        if (MAX_SPEED > speed) {            speed += ACCELERATION * (movingDirection == MovingDirection.BACKWARD ? -1 : 1);        }    }    public void rotate(Direction direction) {        if (direction == Direction.LEFT) {            angle -= ANGLE_CHANGE;        } else {            angle += ANGLE_CHANGE;        }    }    public void speedDown() {        isNeedUpdate = true;        if (speed > 0) {            speed -= ACCELERATION;        } else if (speed < 0) {            speed += ACCELERATION;        }    }    public Point getPosition() {        return position;    }    public void setObjectListener(ObjectListener objectListener) {        this.objectListener = objectListener;    }    public double getAngle() {        return (angle * 180) / Math.PI;    }}