package ru.rsreu.vasilev.dd.model;import javafx.geometry.Bounds;import javafx.scene.shape.Polygon;import javafx.scene.shape.Shape;import ru.rsreu.vasilev.dd.view.*;import java.io.Serializable;import java.util.HashSet;import java.util.Set;public class Car extends Thread implements Serializable {    private static final double ANGLE_CHANGE = 0.1;    private static final double ACCELERATION = 0.4;    private static final double MAX_SPEED = 6;    private static final int NUMBER_LIVES_START = 10;    private static final int TIME_SLEEP = 20;    private transient ObjectListener objectListener;    private final Point position;    private final Model modelGame;    private final Set<Direction> directions;    private final String name;    private double speed = 0;    private double angle = 0;    private int lives = 10;    private int countIterationsAfterCollide = 0;    private boolean isStopped = false;    private Listener gameListener;    public Car(Model modelGame, int x, int y, String name) {        this.position = new Point(x, y);        this.modelGame = modelGame;        setDaemon(true);        directions = new HashSet<>();        this.name = name;        this.gameListener = gameListener;    }    public void initialize() {        gameListener.handle(this, EventType.CREATE_CAR);    }    @Override    public void run() {        while (!isInterrupted()) {            if (modelGame.isPause()) {                try {                    synchronized (Model.BLOCK) {                        Model.BLOCK.wait();                    }                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            synchronized (Model.BLOCK) {                if (!directions.isEmpty()) {                    updateSpeeds();                } else {                    speedDown();                }                moveCar();                checkCollides();                checkWin();            }            objectListener.handle(this, ObjectEventType.UPDATE);            try {                sleep(TIME_SLEEP);            } catch (InterruptedException e) {                break;            }        }    }    private double getSpeedY() {        return Math.cos(angle) * speed;    }    private double getSpeedX() {        return Math.sin(angle) * speed;    }    private void checkWin() {        if ((int) (position.getX() / View.WIDTH_SQUARE) == (int) (modelGame.getFinalPoint().getX()) &&                modelGame.getHeight() - 1 - (int) (position.getY() / View.WIDTH_SQUARE) ==                        (int) (modelGame.getFinalPoint().getY())) {            modelGame.stopAllCars(this);        }    }    private void moveCar() {        double newX = position.getX() + getSpeedX();        double newY = position.getY() + getSpeedY();        position.setY(newY);        position.setX(newX);    }    private void checkCollides() {        if (isCollidedCars() || isCollidesWalls()) {            speed = -2 * speed;            moveCar();            speed = 0;            if (countIterationsAfterCollide-- == 0) {                lives--;                this.countIterationsAfterCollide = NUMBER_LIVES_START;            }            if (lives < 1) {                this.interrupt();            }        }    }    private boolean isCollidesWalls() {        final int topOffset = (View.HEIGHT_TOP_PANEL) / View.WIDTH_SQUARE;        final Polygon polygon = getPolygon();        final Bounds boundsInParent = polygon.getBoundsInParent();        double newMinX = (boundsInParent.getMinX() + getSpeedX()) / View.WIDTH_SQUARE;        double newMinY = (boundsInParent.getMinY() + getSpeedY()) / View.WIDTH_SQUARE - topOffset;        double newMaxX = (boundsInParent.getMaxX() + getSpeedX()) / View.WIDTH_SQUARE;        double newMaxY = (boundsInParent.getMaxY() + getSpeedY()) / View.WIDTH_SQUARE - topOffset;        return isCollidedWall(newMinX, newMinY) || isCollidedWall(newMaxX, newMaxY);    }    private boolean isCollidedWall(double newX, double newY) {        return modelGame.getHeight() <= ((int) newY) || (newY <= 0) ||                modelGame.getWidth() <= (int) newX || (newX < 0) ||                !modelGame.getMap()[(int) newY][(int) newX];    }    private boolean isCollidedCars() {        boolean isCollided = false;        for (Car car : modelGame.getCars()) {            if (!car.equals(this) && isCollidedCar(car)) {                isCollided = true;            }        }        return isCollided;    }    private boolean isCollidedCar(Car car) {        final Polygon bounds = getPolygon();        return !Shape.intersect(bounds, car.getPolygon()).getBoundsInLocal().isEmpty();    }    private void updateSpeeds() {        if (!isStopped) {            if (directions.contains(Direction.UP) && !isCollidesWalls()) {                speedUp(MovingDirection.FORWARD);            } else if (directions.contains(Direction.DOWN) && !isCollidesWalls()) {                speedUp(MovingDirection.BACKWARD);            }            if (directions.contains(Direction.RIGHT)) {                rotate(Direction.RIGHT);            } else if (directions.contains(Direction.LEFT)) {                rotate(Direction.LEFT);            }        }    }    private void speedUp(MovingDirection movingDirection) {        if (MAX_SPEED > speed) {            speed += ACCELERATION * (movingDirection == MovingDirection.BACKWARD ? -1 : 1);        }    }    private void rotate(Direction direction) {        if (direction == Direction.LEFT) {            angle -= ANGLE_CHANGE;        } else {            angle += ANGLE_CHANGE;        }    }    private void speedDown() {        if (speed > 0) {            speed -= ACCELERATION;            if (speed - ACCELERATION < 0) {                speed = 0;            }        } else if (speed < 0) {            speed += ACCELERATION;            if (speed - ACCELERATION > 0) {                speed = 0;            }        }    }    public Point getPosition() {        return position;    }    public void setObjectListener(ObjectListener objectListener) {        this.objectListener = objectListener;    }    public double getAngle() {        return Math.toDegrees(angle);    }    public Set<Direction> getDirections() {        return directions;    }    public Polygon getPolygon() {        return (Polygon) objectListener;    }    public void setStopped(boolean stopped) {        isStopped = stopped;    }    @Override    public String toString() {        return name;    }    public int getLives() {        return lives;    }    public void setGameListener(Listener gameListener) {        this.gameListener = gameListener;    }}