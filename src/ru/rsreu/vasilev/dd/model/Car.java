package ru.rsreu.vasilev.dd.model;import javafx.geometry.Bounds;import ru.rsreu.vasilev.dd.view.*;import java.util.HashSet;import java.util.Set;public class Car extends Thread {    private static final double ANGLE_CHANGE = 0.1;    private static final int TIME_SLEEP = 20;    private final Point position;    private ObjectListener objectListener;    private double speed = 0;    private double angle = 0;    private static final double ACCELERATION = 0.2;    private boolean isNeedUpdate = true;    private static final double MAX_SPEED = 6;    private final Model modelGame;    private Set<Direction> directions;    private int lives = 10;    public Car(Model modelGame, int x, int y, Listener listener) {        this.position = new Point(x, y);        this.modelGame = modelGame;        setDaemon(true);        directions = new HashSet<>();        listener.handle(this, EventType.CREATE_CAR);    }    @Override    public void run() {        while (!isInterrupted()) {            if (isNeedUpdate) {                isNeedUpdate = false;                updateSpeeds();                moveCar();                objectListener.handle(this, ObjectEventType.UPDATE);                checkWin();            } else {                speedDown();            }            try {                sleep(TIME_SLEEP);            } catch (InterruptedException e) {                break;            }        }    }    private double getSpeedY() {        return Math.cos(angle) * speed;    }    private double getSpeedX() {        return Math.sin(angle) * speed;    }    private void checkWin() {        if ((int) (position.getX() / View.WIDTH_SQUARE) == (int) (modelGame.getFinalPoint().getX()) &&                modelGame.getHeight() - 1 - (int) (position.getY() / View.WIDTH_SQUARE) ==                        (int) (modelGame.getFinalPoint().getY())) {            modelGame.stopAllCars(this);        }    }    private void moveCar() {        double newX = position.getX() + getSpeedX();        double newY = position.getY() + getSpeedY();        final Bounds bounds = getBounds();        double newMinX = bounds.getMinX() + getSpeedX();        double newMinY = bounds.getMinY() + getSpeedY();        double newMaxX = bounds.getMaxX() + getSpeedX();        double newMaxY = bounds.getMaxY() + getSpeedY();        if (isNotCollidedWall(newMinX, newMinY) && isNotCollidedWall(newMaxX, newMaxY) && !isCollidedCars()) {            position.setY(newY);            position.setX(newX);        }    }    private boolean isNotCollidedWall(double newX, double newY) {        return modelGame.getHeight() > ((int) newY / View.WIDTH_SQUARE) && newY > 0 &&                modelGame.getWidth() > (int) newX / View.WIDTH_SQUARE && newX >= 0 &&                modelGame.getMap()[modelGame.getHeight() - (int) newY / View.WIDTH_SQUARE - 1][                        (int) newX / View.WIDTH_SQUARE];    }    private boolean isCollidedCars() {        synchronized (Model.BLOCK) {            boolean isCollided = false;            for (Car car :                    modelGame.getCars()) {                if (!car.equals(this)) {                    if (isCollided(car)) {                        isCollided = true;                        if (lives > 1) {                            lives--;                        } else {                            this.interrupt();                        }                    }                }            }            return isCollided;        }    }    private boolean isCollided(Car car) {        return getBounds().intersects(car.getBounds());    }    private void updateSpeeds() {        if (directions.contains(Direction.UP)) {            speedUp(MovingDirection.FORWARD);        } else if (directions.contains(Direction.DOWN)) {            speedUp(MovingDirection.BACKWARD);        }        if (directions.contains(Direction.RIGHT)) {            rotate(Direction.RIGHT);        } else if (directions.contains(Direction.LEFT)) {            rotate(Direction.LEFT);        }    }    private void speedUp(MovingDirection movingDirection) {        isNeedUpdate = true;        if (MAX_SPEED > speed) {            speed += ACCELERATION * (movingDirection == MovingDirection.BACKWARD ? -1 : 1);        }    }    private void rotate(Direction direction) {        if (direction == Direction.LEFT) {            angle -= ANGLE_CHANGE;        } else {            angle += ANGLE_CHANGE;        }    }    private void speedDown() {        isNeedUpdate = true;        if (speed > 0) {            speed -= ACCELERATION;        } else if (speed < 0) {            speed += ACCELERATION;        }    }    public Point getPosition() {        return position;    }    public void setObjectListener(ObjectListener objectListener) {        this.objectListener = objectListener;    }    public double getAngle() {        return Math.toDegrees(angle);    }    public Set<Direction> getDirections() {        return directions;    }    public Bounds getBounds() {        final CarView carView = (CarView) this.objectListener;        return carView.localToScene(carView.getBoundsInLocal());    }}