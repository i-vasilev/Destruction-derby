package ru.rsreu.vasilev.dd.model;import java.util.HashSet;import java.util.Set;import javafx.scene.input.KeyCode;import ru.rsreu.vasilev.dd.view.EventType;import ru.rsreu.vasilev.dd.view.Listener;import ru.rsreu.vasilev.dd.view.ObjectEventType;import ru.rsreu.vasilev.dd.view.ObjectListener;import ru.rsreu.vasilev.dd.view.View;public class Car extends Thread {    private static final double ANGLE_CHANGE = 0.1;    private static final int TIME_SLEEP = 20;    private final Point position;    private final Listener listenerGame;    private ObjectListener objectListener;    private double speed = 0;    private double angle = 0;    private static final double ACCELERATION = 0.2;    private boolean isPlayUser = false;    private boolean isNeedUpdate = true;    private static final double MAX_SPEED = 6;    private final Set<KeyCode> pressedKeys = new HashSet<>();    private final Model modelGame;    public Car(Model modelGame, int x, int y, Listener listener, boolean isPlayUser) {        this(modelGame, x, y, listener);        this.isPlayUser = isPlayUser;    }    public Car(Model modelGame, int x, int y, Listener listener) {        this.position = new Point(x, y);        this.modelGame = modelGame;        setDaemon(true);        listenerGame = listener;        listenerGame.handle(this, EventType.CREATE_CAR);    }    @Override    public void run() {        while (true) {            if (isNeedUpdate) {                if (!isPlayUser) {                    checkMapAndSetKeys();                    speedUp(MovingDirection.FORWARD);                } else {                    isNeedUpdate = false;                }                updateSpeeds();                double speedY = Math.cos(angle) * speed;                double speedX = Math.sin(angle) * speed;                moveCar(speedY, speedX);                objectListener.handle(this, ObjectEventType.UPDATE);            } else {                speedDown();            }            try {                sleep(TIME_SLEEP);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private synchronized void moveCar(double speedY, double speedX) {        double newY = position.getY() + speedY;        double newX = position.getX() + speedX;        if (modelGame.getHeight() > ((int)newY / View.WIDTH_SQUARE - 1) &&                modelGame.getHeight() > ((int)newY / View.WIDTH_SQUARE) && newY > 0 &&                modelGame.getWidth() > (int)newX / View.WIDTH_SQUARE && newX >= 0 &&                modelGame.getMap()[modelGame.getHeight() - (int)newY / View.WIDTH_SQUARE - 1][                        (int)newX / View.WIDTH_SQUARE]) {            position.setY(newY);            position.setX(newX);        }    }    public void updateSpeeds() {        if (pressedKeys.contains(KeyCode.UP)) {            speedUp(MovingDirection.FORWARD);        } else if (pressedKeys.contains(KeyCode.DOWN)) {            speedUp(MovingDirection.BACKWARD);        }        if (pressedKeys.contains(KeyCode.RIGHT)) {            rotate(Direction.RIGHT);        } else if (pressedKeys.contains(KeyCode.LEFT)) {            rotate(Direction.LEFT);        }    }    public void speedUp(MovingDirection movingDirection) {        isNeedUpdate = true;        if (MAX_SPEED > speed) {            speed += ACCELERATION * (movingDirection == MovingDirection.BACKWARD ? -1 : 1);        }    }    public void rotate(Direction direction) {        if (direction == Direction.LEFT) {            angle -= ANGLE_CHANGE;        } else {            angle += ANGLE_CHANGE;        }    }    public void speedDown() {        isNeedUpdate = true;        if (speed > 0) {            speed -= ACCELERATION;        } else if (speed < 0) {            speed += ACCELERATION;        }    }    private double getDeviation() {        return Math.abs(angle % Math.PI / 2);    }    private Direction getDirection() {        final Direction direction;        final boolean isOdd = (int)(angle / Math.PI / 2) == 0;        final boolean isPositive = angle > 0;        final double absAngle = Math.abs(angle);        if (isOdd ^ isPositive) {            if (absAngle % Math.PI <= Math.PI / 4) {                direction = Direction.UP;            } else if (absAngle % Math.PI > Math.PI / 4 && absAngle % Math.PI <= 3 * Math.PI / 4) {                direction = Direction.LEFT;            } else {                direction = Direction.DOWN;            }        } else {            if (absAngle % Math.PI <= Math.PI / 4) {                direction = Direction.DOWN;            } else if (absAngle % Math.PI > Math.PI / 4 && absAngle % Math.PI <= 3 * Math.PI / 4) {                direction = Direction.RIGHT;            } else {                direction = Direction.UP;            }        }        return direction;    }    private boolean isHasClearWay(Direction direction) {        int y = (int)(modelGame.getHeight() - getPosition().getY() / 100);        int x = (int)(getPosition().getX() / 100);        if (direction.equals(Direction.RIGHT)) {            x++;        } else if (direction.equals(Direction.LEFT)) {            x--;        } else if (direction.equals(Direction.DOWN)) {            y += 1;        } else {            y -= 1;        }        if (x >= 0 && x < modelGame.getWidth() && y >= 0 && y < modelGame.getHeight()) {            return modelGame.getMap()[y][x];        }        return false;    }    public void checkMapAndSetKeys() {        final Direction direction = getDirection();        final boolean rightWay;        final boolean leftWay;        final boolean upWay = isHasClearWay(direction);        if (direction.equals(Direction.RIGHT)) {            rightWay = isHasClearWay(Direction.DOWN);            leftWay = isHasClearWay(Direction.UP);        } else if (direction.equals(Direction.UP)) {            rightWay = isHasClearWay(Direction.RIGHT);            leftWay = isHasClearWay(Direction.LEFT);        } else if (direction.equals(Direction.LEFT)) {            rightWay = isHasClearWay(Direction.UP);            leftWay = isHasClearWay(Direction.DOWN);        } else {            rightWay = isHasClearWay(Direction.LEFT);            leftWay = isHasClearWay(Direction.RIGHT);        }        if (!upWay) {            if (rightWay) {                addKey(KeyCode.RIGHT);            } else if (leftWay) {                addKey(KeyCode.LEFT);            }        } else {            if (getDeviation() < 0.1) {                removeKey(KeyCode.RIGHT);                removeKey(KeyCode.LEFT);            }        }    }    public Point getPosition() {        return position;    }    public void setObjectListener(ObjectListener objectListener) {        this.objectListener = objectListener;    }    public double getAngle() {        return (angle * 180) / Math.PI;    }    public void addKey(KeyCode keyCode) {        pressedKeys.add(keyCode);    }    public void removeKey(KeyCode keyCode) {        pressedKeys.remove(keyCode);    }}